# QTIA_backtest  
QTIA_backtest是一个简单的cpp回测框架。回放本地tick数据, 提供下单、撤单api, 进行模拟撮合, 以下简述开发思路  

## 开发思路  
1.Public模块声明了回测框架基类和协议，之所以叫Public，含义是该目录对所有其他组件公开，是公共声明放置的地方。  
基类中使用了观察者模式，声明了MDSubscriber(行情订阅抽象类)和TradeSubscriber(成交订阅抽象类)，实现代码的解耦。比如模拟撮合类在撮合时需要获取行情，所以其继承重写MDSubscriber；策略需要获得行情数据和成交数据，所以其同时继承重写MDSubscriber和TradeSubscriber。  
协议是对业务相关数据结构(行情数据、成交数据等)、常量的声明。  


2.Replayer模块实现了历史行情回放功能，基于生产者消费者模型, 声明和实现如下类  
CsvLoader: 从本地csv中逐行读取行情数据，并解析为框架内部行情数据类。  
MDCache: 行情数据缓存，是对行情数据队列的封装。使用deque存放诸多批次(batch)数据，batch使用vector存放框架内部行情数据类，并且在出入时进行加锁操作。封装的目的是为了未来使用更高级的数据结构提高性能，比如使用无锁队列替代deque。在配置中可以指定一个batch存放数据的多少、队列中可以容纳多少个batch，从而可以简单估算内存占用，避免OOM的问题。  
MDLoader: 封装了一个生产者线程，使用CsvLoader不断读取数据，打包放入MDCache  
MDPublisher: 封装了一个消费者线程，不断从MDCache中取出数据，触发MDSubscriber的回调函数  
Runner: 将这些组件组合  

3.Matcher模块实现了基本的模拟撮合功能，声明和实现如下类：  
OrderQueue: 买单/卖单队列的封装。使用map作为挂单队列，键为价格，值为装了订单数据类的deque，实现价格优先、时间优先的方式撮合。类似MDCache，未来可以使用更高级的数据结构提高性能。  
TradePublisher: 模拟撮合器父类，保留了MatchOrder函数作为核心撮合逻辑，将其解耦出来，不同的撮合逻辑可以继承该类，重写MatchOrder函数。其本身主要实现了接收行情并撮合，产生成交回报并触发TradeSubscriber的回调函数的功能。  
SimpleMatcher: 继承TradePublisher，实现了简单的撮合逻辑：比如撮合买单，从买单队列中从高价到低价取出排队的订单，依次比较买价和最新价，若最新价小于买价，则产生成交。用两个线程来对买队列和卖队列进行同时撮合。使用两个线程的原因是，希望可以做到买卖队列同时撮合，没有先后顺序。在未来可以考虑使用线程池生产线程，或者其他更好的方式。  

## 策略实现案例  
在Test目录下的main.cpp中实现了一个“策略”，逻辑是当第一个tick到来时调用api的下单函数进行下单，打印出成交回报信息。  

## 写在最后  
主要实现了以上内容，其他内容比如OrdMgr订单管理模块等等，都还没有时间思考和实现。这个项目是基于我看过的两个开源交易系统、实习经历和自己的思考，利用晚上的空闲时间开发的，是自己学习面向对象编程、C++11、多线程编程、linux下C++开发的经历的小总结，还有很多不足之处。作为我的兴趣，在未来有时间时会基于这个项目的代码重构，实现一个简单的回测和交易和一的交易系统      